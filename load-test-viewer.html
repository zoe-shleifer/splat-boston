<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Splat Boston - Load Test Viewer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #controls {
            background: #2c3e50;
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        #controls h1 {
            font-size: 20px;
            margin: 0;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .control-group label {
            font-size: 14px;
            font-weight: 500;
        }

        .control-group input {
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }

        .control-group button {
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
        }

        .control-group button:hover {
            background: #2980b9;
        }

        .control-group button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        #stats {
            background: #34495e;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-box {
            background: #2c3e50;
            padding: 10px;
            border-radius: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: #95a5a6;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: white;
        }

        .stat-value.connected {
            color: #2ecc71;
        }

        .stat-value.disconnected {
            color: #e74c3c;
        }

        #map {
            flex: 1;
            background: #f0f0f0;
        }

        #activity-log {
            height: 150px;
            background: #1e1e1e;
            color: #d4d4d4;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            border-top: 1px solid #333;
        }

        .log-entry {
            padding: 2px 0;
            border-bottom: 1px solid #333;
        }

        .log-time {
            color: #608b4e;
        }

        .log-chunk {
            color: #569cd6;
        }

        .log-paint {
            color: #dcdcaa;
        }

        .log-user {
            color: #4ec9b0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1>ðŸŽ¨ Splat Boston - Load Test Viewer</h1>
        <div class="control-group">
            <label>API:</label>
            <input type="text" id="apiUrl" value="http://localhost:8080" />
        </div>
        <div class="control-group">
            <button id="connectBtn" onclick="connect()">Connect</button>
            <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
        </div>
    </div>

    <div id="stats">
        <div class="stat-box">
            <div class="stat-label">Connection Status</div>
            <div class="stat-value disconnected" id="status">Disconnected</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Active Chunks</div>
            <div class="stat-value" id="chunks">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Total Paints</div>
            <div class="stat-value" id="paints">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Paints/sec</div>
            <div class="stat-value" id="rate">0.0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Painted Tiles</div>
            <div class="stat-value" id="tiles">0</div>
        </div>
    </div>

    <div id="map"></div>

    <div id="activity-log"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const BOSTON_CENTER = [42.3601, -71.0589];
        const TILE_SIZE_METERS = 10;
        const CHUNK_SIZE = 256;

        const COLORS = [
            '#FF0000', // 1: Red
            '#FFA500', // 2: Orange
            '#FFFF00', // 3: Yellow
            '#00FF00', // 4: Green
            '#00FFFF', // 5: Cyan
            '#0000FF', // 6: Blue
            '#FF00FF', // 7: Magenta
            '#FFFFFF', // 8: White
        ];

        let map;
        let paintedTiles = new Map();
        let wsConnections = new Map();
        let stats = {
            paints: 0,
            tiles: 0,
            startTime: null,
        };

        // Coordinate conversion
        function latLonToTileXY(lat, lon) {
            const R = 6378137;
            const metersPerTile = 10;
            const originLat = 0;
            const originLon = 0;
            
            const latRad = (lat * Math.PI) / 180;
            const originLatRad = (originLat * Math.PI) / 180;
            
            const x = R * ((lon - originLon) * Math.PI / 180);
            const y = R * Math.log(Math.tan(Math.PI / 4 + latRad / 2) / Math.tan(Math.PI / 4 + originLatRad / 2));
            
            return {
                x: Math.floor(x / metersPerTile),
                y: Math.floor(y / metersPerTile),
            };
        }

        function tileXYToLatLon(x, y) {
            const R = 6378137;
            const metersPerTile = 10;
            const originLat = 0;
            const originLon = 0;
            
            const xMeters = x * metersPerTile;
            const yMeters = y * metersPerTile;
            
            const lon = originLon + (xMeters / R) * (180 / Math.PI);
            const lat = (Math.atan(Math.exp(yMeters / R)) - Math.PI / 4) * 2 * (180 / Math.PI);
            
            return { lat, lon };
        }

        function chunkOf(x, y) {
            return {
                cx: Math.floor(x / CHUNK_SIZE),
                cy: Math.floor(y / CHUNK_SIZE),
            };
        }

        function tileBounds(x, y) {
            const sw = tileXYToLatLon(x, y);
            const ne = tileXYToLatLon(x + 1, y + 1);
            return [[sw.lat, sw.lon], [ne.lat, ne.lon]];
        }

        function colorIndexToHex(index) {
            if (index === 0 || index < 1 || index > 8) return 'transparent';
            return COLORS[index - 1];
        }

        function initMap() {
            map = L.map('map', {
                center: BOSTON_CENTER,
                zoom: 13,
                zoomControl: true,
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors',
                maxZoom: 18,
            }).addTo(map);

            // Subscribe to visible chunks when map moves
            map.on('moveend', updateVisibleChunks);
            map.on('zoomend', updateVisibleChunks);

            log('Map initialized');
        }

        function updateVisibleChunks() {
            if (!map) return;

            const bounds = map.getBounds();
            const sw = bounds.getSouthWest();
            const ne = bounds.getNorthEast();

            const swTile = latLonToTileXY(sw.lat, sw.lng);
            const neTile = latLonToTileXY(ne.lat, ne.lng);

            const swChunk = chunkOf(swTile.x, swTile.y);
            const neChunk = chunkOf(neTile.x, neTile.y);

            const visibleChunks = new Set();

            // Get all visible chunks
            for (let cx = Math.min(swChunk.cx, neChunk.cx); cx <= Math.max(swChunk.cx, neChunk.cx); cx++) {
                for (let cy = Math.min(swChunk.cy, neChunk.cy); cy <= Math.max(swChunk.cy, neChunk.cy); cy++) {
                    visibleChunks.add(`${cx}:${cy}`);
                }
            }

            // Limit to 25 chunks max
            if (visibleChunks.size > 25) {
                return;
            }

            // Unsubscribe from chunks no longer visible
            wsConnections.forEach((ws, key) => {
                if (!visibleChunks.has(key)) {
                    ws.close();
                    wsConnections.delete(key);
                    log(`Unsubscribed from chunk ${key}`);
                }
            });

            // Subscribe to new visible chunks
            visibleChunks.forEach(key => {
                if (!wsConnections.has(key)) {
                    const [cx, cy] = key.split(':').map(Number);
                    subscribeToChunk(cx, cy);
                }
            });

            updateStats();
        }

        function subscribeToChunk(cx, cy) {
            const apiUrl = document.getElementById('apiUrl').value;
            const wsUrl = apiUrl.replace('http://', 'ws://').replace('https://', 'wss://');
            const url = `${wsUrl}/sub?cx=${cx}&cy=${cy}`;
            const key = `${cx}:${cy}`;

            try {
                const ws = new WebSocket(url);

                ws.onopen = () => {
                    log(`Subscribed to chunk (${cx}, ${cy})`, 'chunk');
                    updateStats();
                };

                ws.onmessage = (event) => {
                    const delta = JSON.parse(event.data);
                    handlePaint(cx, cy, delta);
                };

                ws.onerror = (error) => {
                    console.error(`WebSocket error for chunk (${cx}, ${cy}):`, error);
                };

                ws.onclose = () => {
                    wsConnections.delete(key);
                    updateStats();
                };

                wsConnections.set(key, ws);
            } catch (error) {
                console.error(`Failed to subscribe to chunk (${cx}, ${cy}):`, error);
            }
        }

        function handlePaint(cx, cy, delta) {
            stats.paints++;

            // Calculate tile coordinates
            const localY = Math.floor(delta.o / CHUNK_SIZE);
            const localX = delta.o % CHUNK_SIZE;
            const x = cx * CHUNK_SIZE + localX;
            const y = cy * CHUNK_SIZE + localY;
            const tileKey = `${x}_${y}`;

            if (delta.color === 0) {
                // Remove tile
                const tile = paintedTiles.get(tileKey);
                if (tile && tile.rectangle) {
                    map.removeLayer(tile.rectangle);
                }
                paintedTiles.delete(tileKey);
                stats.tiles--;
            } else {
                // Add or update tile
                const color = colorIndexToHex(delta.color);
                const bounds = tileBounds(x, y);

                let tile = paintedTiles.get(tileKey);
                if (tile && tile.rectangle) {
                    map.removeLayer(tile.rectangle);
                }

                const rectangle = L.rectangle(bounds, {
                    color: color,
                    fillColor: color,
                    fillOpacity: 0.8,
                    weight: 0.5,
                }).addTo(map);

                if (!tile) {
                    stats.tiles++;
                }

                paintedTiles.set(tileKey, { rectangle, color });

                log(`Paint: chunk (${cx},${cy}) offset ${delta.o} color ${delta.color}`, 'paint');
            }

            updateStats();
        }

        function connect() {
            document.getElementById('connectBtn').disabled = true;
            document.getElementById('disconnectBtn').disabled = false;
            document.getElementById('status').textContent = 'Connected';
            document.getElementById('status').classList.remove('disconnected');
            document.getElementById('status').classList.add('connected');
            
            stats.startTime = Date.now();
            
            log('Connected - watching for paint events', 'user');
            updateVisibleChunks();
            
            // Start rate calculation
            setInterval(updateRate, 1000);
        }

        function disconnect() {
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            document.getElementById('status').textContent = 'Disconnected';
            document.getElementById('status').classList.remove('connected');
            document.getElementById('status').classList.add('disconnected');

            wsConnections.forEach(ws => ws.close());
            wsConnections.clear();

            log('Disconnected', 'user');
            updateStats();
        }

        function updateStats() {
            document.getElementById('chunks').textContent = wsConnections.size;
            document.getElementById('paints').textContent = stats.paints;
            document.getElementById('tiles').textContent = stats.tiles;
        }

        function updateRate() {
            if (!stats.startTime) return;
            const elapsed = (Date.now() - stats.startTime) / 1000;
            const rate = stats.paints / elapsed;
            document.getElementById('rate').textContent = rate.toFixed(1);
        }

        function log(message, type = 'info') {
            const logDiv = document.getElementById('activity-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            const time = new Date().toLocaleTimeString();
            const timeSpan = `<span class="log-time">[${time}]</span>`;
            
            let styledMessage = message;
            if (type === 'chunk') {
                styledMessage = message.replace(/chunk \([^)]+\)/, m => `<span class="log-chunk">${m}</span>`);
            } else if (type === 'paint') {
                styledMessage = message.replace(/chunk \([^)]+\)/, m => `<span class="log-chunk">${m}</span>`);
                styledMessage = styledMessage.replace(/offset \d+/, m => `<span class="log-paint">${m}</span>`);
            } else if (type === 'user') {
                styledMessage = `<span class="log-user">${message}</span>`;
            }
            
            entry.innerHTML = `${timeSpan} ${styledMessage}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;

            // Keep only last 100 entries
            while (logDiv.children.length > 100) {
                logDiv.removeChild(logDiv.firstChild);
            }
        }

        // Initialize on load
        window.onload = () => {
            initMap();
        };
    </script>
</body>
</html>

